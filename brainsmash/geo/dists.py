""" Functions to compute geodesic distance matrices from neuroimaging files.

Surface file + map -> dense or parcellated geodesic or euclid dist matrix (txt)
X CIFTI file (incl. subcortex) -> dense Euclid distmat (txt)

"""

from ..neuro.io import load_data, export_cifti_mapping
from ..utils import checks
from scipy.spatial.distance import pdist, squareform, cdist
from tempfile import gettempdir
from os import path, system, stat
import numpy as np
from pathlib import Path


def compute_cortex_dists(surface, fout, euclid=False):
    """
    Compute vertex-wise geodesic distance matrix for a cortical hemisphere.

    Parameters
    ----------
    surface : str
        absolute path to a surface GIFTI file (.surf.gii) from which to compute
        distances
    fout : str
        name of output file, WITHOUT extension, WITH absolute path to directory
        in which it will be saved
    euclid : bool, default False
        if True, compute Euclidean distances; if False, compute geodesic dist

    Returns
    -------
    TODO

    """

    if path.exists(fout):
        raise RuntimeWarning("{} will be overwritten".format(fout))

    # Check that parent directory exists
    pardir = Path(fout).parent
    if not pardir.exists:
        raise IOError("Output directory does not exist: {}".format(str(pardir)))

    # Strip file extensions and define output text file
    fout = checks.stripext(fout)
    dist_file = fout + '.txt'

    # Load surface file
    coords = checks.check_surface(surface)

    if euclid:  # Pairwise Euclidean distance matrix
        _euclidean_distances(dist_file=dist_file, coords=coords)
    else:  # Pairwise geodesic distance matrix
        _geodesic_distances(
            surface=surface, dist_file=dist_file, coords=coords)


def _euclidean_distances(dist_file, coords):
    """
    TODO

    Parameters
    ----------
    dist_file
    coords

    Returns
    -------

    """
    # distmat = squareform(pdist(coords, metric='euclidean'))
    # distmat = cdist(coords, coords)

    with open(dist_file, 'w') as fp:
        # Compute distances one row at a time to reduce memory burden
        for il, l in enumerate(fp):  # Loop over lines of file
            distances = cdist(
                np.expand_dims(coords[il], 0), coords).squeeze()
            line = ",".join([str(d) for d in distances]) + "\n"
            fp.write(line)

    checks.file_exists(f=dist_file)


def _geodesic_distances(surface, dist_file, coords):
    """
    TODO

    Parameters
    ----------
    surface
    dist_file
    coords

    Returns
    -------

    """
    nvert = coords.shape[0]

    # Files produced at runtime by Workbench commands
    temp = gettempdir()
    coord_file = path.join(temp, "coords.func.gii")
    distance_metric_file = path.join(temp, "dist.func.gii")

    # Create a metric file containing the coordinates of each surface vertex
    cmd = 'wb_command -surface-coordinates-to-metric "{0:s}" "{1:s}"'
    system(cmd.format(surface, coord_file))

    with open(dist_file, 'w') as f:
        for ii in np.arange(coords.shape[0]):
            cmd = 'wb_command -surface-geodesic-distance "{0}" {1} "{2}" '
            system(cmd.format(surface, ii, distance_metric_file))
            distance_from_iv = load_data(distance_metric_file)
            line = " ".join([str(dij) for dij in distance_from_iv])
            f.write(line + "\n")
            if not (ii % 1000):
                print("Vertex {} of {} complete.".format(ii+1, nvert))

    checks.file_exists(f=dist_file)


def compute_geodist_parcel(dists_text, parcel_labels, output):
    """
    Compute parcellated geodesic distance matrix.

    Parameters
    ----------
    dists_text : str
        text file generated by ``compute_geodist_dense''
    parcel_labels : str
        path to parcellation file  (.dlabel.nii)
    output : str
        path to output text file (to be created)

    Returns
    -------
    TODO

    """

    # Confirm that parent directory exists
    pardir = Path(output).parent
    if not pardir.exists:
        raise IOError("Output directory does not exist: {}".format(str(pardir)))
    output = path.splitext(output)[0] + '.txt'

    print("\n## Computing parcellated geodesic distance matrix ##")
    print("# Input dense distance file: {}".format(dists_text))
    print("# Input parcellation file: {}".format(parcel_labels))
    print("# Output parcellated distance file: {}".format(output))

    # Load surface vertex parcel labels
    labels = load_data(parcel_labels)

    with open(dists_text, 'r') as fp:

        # Get size of distance matrix and ensure that the number of parcel
        # labels equals the number of surface vertices
        nrows = 1
        ncols = len(fp.readline().split(" "))
        for l in fp:
            if l.rstrip():
                nrows += 1
        fp.seek(0)  # return to beginning of file
        assert labels.size == nrows == ncols

        # Skip parcel label 0 if present -- not a parcel!
        unique_labels = np.unique(labels)
        nparcels = unique_labels.size
        if 0 in unique_labels:
            unique_labels = unique_labels[unique_labels != 0]
            assert unique_labels.size == (nparcels - 1)
            nparcels -= 1

        # Create vertex-level mask for each unique cortical parcel
        parcel_vertex_mask = {l: labels == l for l in unique_labels}

        # Loop over pairwise parcels at the level of surface vertices
        distance_matrix = np.zeros((nparcels, nparcels))
        for i, li in enumerate(unique_labels[:-1]):

            # Labels of parcels for which to compute mean geodesic distance
            labels_lj = unique_labels[i + 1:]

            # Initialize lists in which to store pairwise vertex-level distances
            parcel_distances = {lj: [] for lj in labels_lj}

            # Loop over vertices with parcel label i
            li_vertices = np.where(parcel_vertex_mask[li])[0]
            for vi in li_vertices:

                # Load distance from vertex vi to every other vertex
                fp.seek(vi)
                d = np.array(fp.readline().split(" "), dtype=np.float32)

                # Update lists w/ dists from vertex vi to vertices in parcel j
                for lj in labels_lj:
                    vi_lj_distances = d[parcel_vertex_mask[lj]]
                    parcel_distances[lj].append(vi_lj_distances)

            # Compute average geodesic distances
            for j, lj in enumerate(labels_lj):
                mean_distance = np.mean(parcel_distances[lj])
                distance_matrix[i, i + j + 1] = mean_distance

            print("# Parcel label %s complete." % str(li))

        # Make final matrix symmetric
        i, j = np.triu_indices(nparcels, k=1)
        distance_matrix[j, i] = distance_matrix[i, j]

        # Write to file
        np.savetxt(fname=output, X=distance_matrix)

        try:
            isnotempty = path.getsize(output) > 0
            if isnotempty:
                return 1
            return 0
        except OSError:
            return 0


def compute_eucliddist_subcortex(image, output):
    """
    Create 3D Euclidean distance matrix for a subcortical ROI.

    Parameters
    ----------
    image : str
        path to NIFTI-format neuroimaging file
    output : str
        path to output text file (to be created)

    Returns
    -------
    output : str
        path to output text file
    """

    # TODO add support for pscalar images once it's worked out in cortex

    # Load CIFTI indices for this map
    # of = nib.load(image)
    scalars = load_data(image)

    # # Get XML from file metadata
    # ext = of.header.extensions
    # root = eT.fromstring(ext[0].get_content())
    # parent_map = {c: p for p in root.iter() for c in p}

    # Load CIFTI mapping
    maps = export_cifti_mapping(image)  # TODO make this only return volume
    if "Subcortex" not in maps.keys():
        e = "\nSubcortical information not found in file header!\n"
        e += "Image file: {}\n".format(image)
        raise TypeError(e)

    # sub is a dataframe indexed by CIFTI index with cols for X,Y,Z coords
    sub = maps['Subcortex'].drop("structure", axis=1)
    # TODO perform step later, first printing unique structures in ROI?

    # Select MNI coords where `scalars` is not NaN
    subctx_inds = sub.index.values
    mask = np.isnan(scalars[subctx_inds])
    coords = sub.iloc[subctx_inds[~mask]].values
    assert coords.shape[0] == (~mask).sum()

    # # Create map from parcel label to pscalar/ptseries index
    # plabel2idx = dict()
    # idx = 0
    # for node in root.iter("Parcel"):
    #     plabel = dict(node.attrib)['Name']
    #     plabel2idx[plabel] = idx
    #     idx += 1

    # Compute Euclidean distance matrix
    distmat = squareform(pdist(coords, metric='euclidean'))

    # Write to file
    np.savetxt(output, distmat)

    return output
