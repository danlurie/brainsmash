""" Functions to compute geodesic distance matrices from neuroimaging files.

Surface file + map -> dense or parcellated geodesic or euclid dist matrix (txt)
X CIFTI file (incl. subcortex) -> dense Euclid distmat (txt)

"""

from ..neuro.io import load_data, export_cifti_mapping
from ..utils import checks
from scipy.spatial.distance import pdist, squareform, cdist
from tempfile import gettempdir
from os import path, system
import numpy as np
from pathlib import Path


def compute_cortex_dists(surface, fout, euclid=False):
    """
    Compute vertex-wise geodesic distance matrix for a cortical hemisphere.

    Parameters
    ----------
    surface : str
        absolute path to a surface GIFTI file (.surf.gii) from which to compute
        distances
    fout : str
        name of output file, WITHOUT extension, WITH absolute path to directory
        in which it will be saved
    euclid : bool, default False
        if True, compute Euclidean distances; if False, compute geodesic dist

    Returns
    -------
    str
        path to output distance matrix file

    """

    if path.exists(fout):
        raise RuntimeWarning("{} will be overwritten".format(fout))

    # Check that parent directory exists
    pardir = Path(fout).parent
    if not pardir.exists:
        raise IOError("Output directory does not exist: {}".format(str(pardir)))

    # Strip file extensions and define output text file
    fout = checks.stripext(fout)
    dist_file = fout + '.txt'

    # Load surface file
    coords = checks.check_surface(surface)

    if euclid:  # Pairwise Euclidean distance matrix
        fout = _euclidean_distances(dist_file=dist_file, coords=coords)
    else:  # Pairwise geodesic distance matrix
        fout = _geodesic_distances(
            surface=surface, dist_file=dist_file, coords=coords)
    return fout


def _euclidean_distances(dist_file, coords):
    """
    Compute pairwise euclidean distance between rows of `coords`. Write results
    to `dist_file`.

    Parameters
    ----------
    dist_file : str
        absolute path to output file, with .txt extension
    coords : (N,3) np.ndarray
        MNI coordinates for N voxels/vertices

    Returns
    -------
    str
        path to output distance matrix file

    Notes
    -----
    Distances are computed one row at a time to reduce memory burden.

    """
    # distmat = squareform(pdist(coords, metric='euclidean'))
    # distmat = cdist(coords, coords)
    with open(dist_file, 'w') as fp:
        for point in coords:
            distances = cdist(
                np.expand_dims(point, 0), coords).squeeze()
            line = " ".join([str(d) for d in distances]) + "\n"
            fp.write(line)
    checks.file_exists(f=dist_file)
    return dist_file


def _geodesic_distances(surface, dist_file, coords):
    """
    Compute pairwise geodesic distance between rows of `coords`. Write results
    to `dist_file`.

    Parameters
    ----------
    surface : str
        absolute path to a surface GIFTI file (.surf.gii) from which to compute
        distances
    dist_file : str
        absolute path to output file, with .txt extension
    coords : (N,3) np.ndarray
        MNI coordinates for N voxels/vertices

    Returns
    -------
    str
        path to output distance matrix file

    Notes
    -----
    This function uses command-line utilities included in Connectome Workbench.
    It requires ~1-2 hours to run.

    """
    nvert = coords.shape[0]

    # Files produced at runtime by Workbench commands
    temp = gettempdir()
    coord_file = path.join(temp, "coords.func.gii")
    distance_metric_file = path.join(temp, "dist.func.gii")

    # Create a metric file containing the coordinates of each surface vertex
    cmd = 'wb_command -surface-coordinates-to-metric "{0:s}" "{1:s}"'
    system(cmd.format(surface, coord_file))

    with open(dist_file, 'w') as f:
        for ii in np.arange(coords.shape[0]):
            cmd = 'wb_command -surface-geodesic-distance "{0}" {1} "{2}" '
            system(cmd.format(surface, ii, distance_metric_file))
            distance_from_iv = load_data(distance_metric_file)
            line = " ".join([str(dij) for dij in distance_from_iv])
            f.write(line + "\n")
            if not (ii % 1000):
                print("Vertex {} of {} complete.".format(ii+1, nvert))
    checks.file_exists(f=dist_file)
    return dist_file


def compute_geodist_parcel(infile, dlabel_file, outfile, delimiter=' '):
    """
    Parcellate a dense distance matrix.

    Parameters
    ----------
    infile : str
        text file generated by ``compute_geodist_dense''
    dlabel_file : str
        path to parcellation file  (.dlabel.nii)
    outfile : str
        path to output text file (to be created)
    delimiter : str
        delimiter between elements in `infile`

    Returns
    -------
    str
        path to output parcellated distance matrix file

    Notes
    -----
    For two parcels A and B, the inter-parcel distance is defined as the mean
    distance between area i in parcel A and area j in parcel B, \forall i,j.

    Inputs `infile` and `dlabel_file` should include the same anatomical
    structures, e.g. the left cortical hemisphere, and should have the same
    number of elements. If you need to isolate one anatomical structure from
    `dlabel_file`, see the following Workbench function:
    https://www.humanconnectome.org/software/workbench-command/-cifti-separate
    """

    if path.exists(outfile):
        raise RuntimeWarning("{} will be overwritten".format(outfile))

    # Check that parent directory exists
    pardir = Path(outfile).parent
    if not pardir.exists:
        raise IOError("Output directory does not exist: {}".format(str(pardir)))

    # Confirm that parent directory exists
    pardir = Path(outfile).parent
    if not pardir.exists:
        raise IOError("Output directory does not exist: {}".format(str(pardir)))

    # Strip file extensions and define output text file
    fout = checks.stripext(outfile)
    dist_file = fout + '.txt'

    # Load surface vertex parcel labels
    labels = checks.check_image_file(dlabel_file)

    with open(infile, 'r') as fp:

        # Compare number of elements in distance matrix to dlabel file
        nrows = 1
        ncols = len(fp.readline().split(delimiter))
        for l in fp:
            if l.rstrip():
                nrows += 1
        fp.seek(0)  # return to beginning of file
        if not (labels.size == nrows == ncols):
            e = "Files must contain same number of areas\n"
            e += "{} areas in {}\n".format(labels.size, dlabel_file)
            e += "{} rows and {} cols in {}".format(nrows, ncols, infile)
            raise ValueError(e)

        # Skip parcel label 0 -> masked value TODO discuss w/ john
        unique_labels = np.unique(labels)
        nparcels = unique_labels.size
        if 0 in unique_labels:
            unique_labels = unique_labels[unique_labels != 0]
            nparcels -= 1

        # Create vertex-level mask for each unique cortical parcel
        parcel_vertex_mask = {l: labels == l for l in unique_labels}

        # Loop over pairwise parcels at the level of surface vertices
        distance_matrix = np.zeros((nparcels, nparcels))
        for i, li in enumerate(unique_labels[:-1]):

            # Labels of parcels for which to compute mean geodesic distance
            labels_lj = unique_labels[i+1:]

            # Initialize lists in which to store pairwise vertex-level distances
            parcel_distances = {lj: [] for lj in labels_lj}

            # Loop over vertices with parcel label i
            li_vertices = np.where(parcel_vertex_mask[li])[0]
            for vi in li_vertices:

                # Load distance from vertex vi to every other vertex
                fp.seek(vi)
                d = np.array(fp.readline().split(delimiter), dtype=np.float32)

                # Update lists w/ dists from vertex vi to vertices in parcel j
                for lj in labels_lj:
                    vi_lj_distances = d[parcel_vertex_mask[lj]]
                    parcel_distances[lj].append(vi_lj_distances)

            # Compute average geodesic distances
            for j, lj in enumerate(labels_lj):
                mean_distance = np.mean(parcel_distances[lj])
                distance_matrix[i, i + j + 1] = mean_distance

            print("# Parcel label %s complete." % str(li))

        # Make final matrix symmetric
        i, j = np.triu_indices(nparcels, k=1)
        distance_matrix[j, i] = distance_matrix[i, j]

        # Write to file
        np.savetxt(fname=dist_file, X=distance_matrix)
        checks.file_exists(dist_file)
        return dist_file


def compute_eucliddist_subcortex(image, output):
    """
    Create 3D Euclidean distance matrix for a subcortical ROI.

    Parameters
    ----------
    image : str
        path to NIFTI-format neuroimaging file
    output : str
        path to output text file (to be created)

    Returns
    -------
    output : str
        path to output text file
    """

    # TODO add support for pscalar images once it's worked out in cortex

    # Load CIFTI indices for this map
    # of = nib.load(image)
    scalars = load_data(image)

    # # Get XML from file metadata
    # ext = of.header.extensions
    # root = eT.fromstring(ext[0].get_content())
    # parent_map = {c: p for p in root.iter() for c in p}

    # Load CIFTI mapping
    maps = export_cifti_mapping(image)  # TODO make this only return volume
    if "Subcortex" not in maps.keys():
        e = "\nSubcortical information not found in file header!\n"
        e += "Image file: {}\n".format(image)
        raise TypeError(e)

    # sub is a dataframe indexed by CIFTI index with cols for X,Y,Z coords
    sub = maps['Subcortex'].drop("structure", axis=1)
    # TODO perform step later, first printing unique structures in ROI?

    # Select MNI coords where `scalars` is not NaN
    subctx_inds = sub.index.values
    mask = np.isnan(scalars[subctx_inds])
    coords = sub.iloc[subctx_inds[~mask]].values
    assert coords.shape[0] == (~mask).sum()

    # # Create map from parcel label to pscalar/ptseries index
    # plabel2idx = dict()
    # idx = 0
    # for node in root.iter("Parcel"):
    #     plabel = dict(node.attrib)['Name']
    #     plabel2idx[plabel] = idx
    #     idx += 1

    # Compute Euclidean distance matrix
    distmat = squareform(pdist(coords, metric='euclidean'))

    # Write to file
    np.savetxt(output, distmat)

    return output
