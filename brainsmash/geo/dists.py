""" Functions to compute geodesic distance matrices from neuroimaging files.

Surface file + map -> dense or parcellated geodesic or euclid dist matrix (txt)
X CIFTI file (incl. subcortex) -> dense Euclid distmat (txt)

"""

from ..neuro.io import load_data, export_cifti_mapping
from ..utils import checks
from scipy.spatial.distance import pdist, squareform, cdist
from tempfile import mkdtemp
from os import path, system
import numpy as np
from pathlib import Path


def compute_cortex_dists(surface, fout, maskfile=None, euclid=False):
    """
    Compute vertex-wise geodesic distance matrix for a cortical hemisphere.

    Parameters
    ----------
    surface : str
        absolute path to a surface GIFTI file (.surf.gii) from which to compute
        distances
    fout : str
        name of output file, WITHOUT extension, WITH absolute path to directory
        in which it will be saved
    maskfile : str, optional
        path to a neuroimaging file containing a mask. scalar data are cast to
        boolean, so all elements not equal to zero are masked
    euclid : bool, optional
        if True, compute Euclidean distances; if False, compute geodesic

    Returns
    -------
    TODO

    """

    # Check that parent directory exists
    pardir = Path(fout).parent
    if not pardir.exists:
        raise IOError("Output directory does not exist: {}".format(str(pardir)))

    # Strip file extensions and define output text file
    fout = checks.stripext(fout)
    dense_distmat = fout + '.txt'

    # Load surface file
    coords = checks.check_surface(surface) if euclid else None

    # Load user-provided mask file
    if maskfile is not None:
        mask = checks.check_image_file(maskfile).astype(bool)
        if mask.size != coords.shape[0]:
            e = "Surface and mask files must contain same number of elements:\n"
            e += "Surface: {}".format(surface)
            e += "Mask: {}".format(maskfile)
            raise ValueError(e)
        nvert = int((~mask).sum())
        verts = np.arange(mask.size)[~mask]
        if euclid:
            coords = coords[~mask]
    else:
        nvert = coords.shape[0]
        verts = np.arange(nvert)

    # Pairwise Euclidean distance matrix
    if euclid:
        # TODO make this computationally efficient (??)
        # dense_distmat = squareform(pdist(coords, metric='euclidean'))
        # cdist(np.expand_dims(XA, 0), XB)
        return

    # Pairwise geodesic distance matrix
    # Files produced at runtime by Connectome Workbench commands
    coord_file = path.join(mkdtemp(), "vertex_coords.func.gii")
    distance_metric_file = path.join(mkdtemp(), "geodist.func.gii")

    # Create a metric file containing the coordinates of each surface vertex
    cmd = 'wb_command -surface-coordinates-to-metric "{0:s}" "{1:s}"'
    system(cmd.format(surface, coord_file))

    with open(dense_distmat, 'w') as f:
        for ii, iv in enumerate(verts):
            cmd = 'wb_command -surface-geodesic-distance "{0}" {1} "{2}" '
            system(cmd.format(surface, iv, distance_metric_file))
            distance_from_iv = load_data(distance_metric_file)
            line = " ".join([str(dij) for dij in distance_from_iv])
            f.write(line + "\n")
            if not (ii % 1000):
                print("Vertex {} of {} complete.".format(ii+1, nvert))

    # Write dense distance matrix


def compute_geodist_parcel(dists_text, parcel_labels, output):
    """
    Compute parcellated geodesic distance matrix.

    Parameters
    ----------
    dists_text : str
        text file generated by ``compute_geodist_dense''
    parcel_labels : str
        path to parcellation file  (.dlabel.nii)
    output : str
        path to output text file (to be created)

    Returns
    -------
    TODO

    """

    # Confirm that parent directory exists
    pardir = Path(output).parent
    if not pardir.exists:
        raise IOError("Output directory does not exist: {}".format(str(pardir)))
    output = path.splitext(output)[0] + '.txt'

    print("\n## Computing parcellated geodesic distance matrix ##")
    print("# Input dense distance file: {}".format(dists_text))
    print("# Input parcellation file: {}".format(parcel_labels))
    print("# Output parcellated distance file: {}".format(output))

    # Load surface vertex parcel labels
    labels = load_data(parcel_labels)

    with open(dists_text, 'r') as fp:

        # Get size of distance matrix and ensure that the number of parcel
        # labels equals the number of surface vertices
        nrows = 1
        ncols = len(fp.readline().split(" "))
        for l in fp:
            if l.rstrip():
                nrows += 1
        fp.seek(0)  # return to beginning of file
        assert labels.size == nrows == ncols

        # Skip parcel label 0 if present -- not a parcel!
        unique_labels = np.unique(labels)
        nparcels = unique_labels.size
        if 0 in unique_labels:
            unique_labels = unique_labels[unique_labels != 0]
            assert unique_labels.size == (nparcels - 1)
            nparcels -= 1

        # Create vertex-level mask for each unique cortical parcel
        parcel_vertex_mask = {l: labels == l for l in unique_labels}

        # Loop over pairwise parcels at the level of surface vertices
        distance_matrix = np.zeros((nparcels, nparcels))
        for i, li in enumerate(unique_labels[:-1]):

            # Labels of parcels for which to compute mean geodesic distance
            labels_lj = unique_labels[i + 1:]

            # Initialize lists in which to store pairwise vertex-level distances
            parcel_distances = {lj: [] for lj in labels_lj}

            # Loop over vertices with parcel label i
            li_vertices = np.where(parcel_vertex_mask[li])[0]
            for vi in li_vertices:

                # Load distance from vertex vi to every other vertex
                fp.seek(vi)
                d = np.array(fp.readline().split(" "), dtype=np.float32)

                # Update lists w/ dists from vertex vi to vertices in parcel j
                for lj in labels_lj:
                    vi_lj_distances = d[parcel_vertex_mask[lj]]
                    parcel_distances[lj].append(vi_lj_distances)

            # Compute average geodesic distances
            for j, lj in enumerate(labels_lj):
                mean_distance = np.mean(parcel_distances[lj])
                distance_matrix[i, i + j + 1] = mean_distance

            print("# Parcel label %s complete." % str(li))

        # Make final matrix symmetric
        i, j = np.triu_indices(nparcels, k=1)
        distance_matrix[j, i] = distance_matrix[i, j]

        # Write to file
        np.savetxt(fname=output, X=distance_matrix)

        try:
            isnotempty = path.getsize(output) > 0
            if isnotempty:
                return 1
            return 0
        except OSError:
            return 0


def compute_eucliddist_subcortex(image, output):
    """
    Create 3D Euclidean distance matrix for a subcortical ROI.

    Parameters
    ----------
    image : str
        path to NIFTI-format neuroimaging file
    output : str
        path to output text file (to be created)

    Returns
    -------
    output : str
        path to output text file
    """

    # TODO add support for pscalar images once it's worked out in cortex

    # Load CIFTI indices for this map
    # of = nib.load(image)
    scalars = load_data(image)

    # # Get XML from file metadata
    # ext = of.header.extensions
    # root = eT.fromstring(ext[0].get_content())
    # parent_map = {c: p for p in root.iter() for c in p}

    # Load CIFTI mapping
    maps = export_cifti_mapping(image)  # TODO make this only return volume
    if "Subcortex" not in maps.keys():
        e = "\nSubcortical information not found in file header!\n"
        e += "Image file: {}\n".format(image)
        raise TypeError(e)

    # sub is a dataframe indexed by CIFTI index with cols for X,Y,Z coords
    sub = maps['Subcortex'].drop("structure", axis=1)
    # TODO perform step later, first printing unique structures in ROI?

    # Select MNI coords where `scalars` is not NaN
    subctx_inds = sub.index.values
    mask = np.isnan(scalars[subctx_inds])
    coords = sub.iloc[subctx_inds[~mask]].values
    assert coords.shape[0] == (~mask).sum()

    # # Create map from parcel label to pscalar/ptseries index
    # plabel2idx = dict()
    # idx = 0
    # for node in root.iter("Parcel"):
    #     plabel = dict(node.attrib)['Name']
    #     plabel2idx[plabel] = idx
    #     idx += 1

    # Compute Euclidean distance matrix
    distmat = squareform(pdist(coords, metric='euclidean'))

    # Write to file
    np.savetxt(output, distmat)

    return output
